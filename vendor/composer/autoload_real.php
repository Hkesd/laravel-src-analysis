<?php

// autoload_real.php @generated by Composer

/**
 * Class ComposerAutoloaderInit901467e07f0d9f8849360bc08fc4ebe6
 *
 * 为了避免冲突增加了hash值
 */
class ComposerAutoloaderInit901467e07f0d9f8849360bc08fc4ebe6
{
    private static $loader;

    /**
     * @param $class
     *
     * getLoader第二部分注册的自动加载函数，为了创建自动加载核心类 ClassLoader
     */
    public static function loadClassLoader($class)
    {
        if ('Composer\Autoload\ClassLoader' === $class) {
            require __DIR__ . '/ClassLoader.php';
        }
    }

    /**
     * 获取loader实例
     *
     * @return \Composer\Autoload\ClassLoader
     */
    public static function getLoader()
    {
        /**
         * ------------------------------------------------------------------------
         * 该函数分为五部分
         *
         * 1. 单例模式
         * 2. 获取自动加载类核心对象 loader
         * 3. 初始化核心类对象
         * 4. 注册自动加载核心类对象
         * 5. 全局函数的自动加载
         * ------------------------------------------------------------------------
         */

        /**
         * ------------------------------------------------------------------------
         * 第一部分
         *
         * 单例模式，自动加载loader只能有一个
         * ------------------------------------------------------------------------
         */
        if (null !== self::$loader) {
            return self::$loader;
        }


        /**
         * ------------------------------------------------------------------------
         * 第二部分
         *
         * 获取自动加载类核心对象
         * ------------------------------------------------------------------------
         */
        // 使用php自动加载机制注册loadClassLoader
        spl_autoload_register(array('ComposerAutoloaderInit901467e07f0d9f8849360bc08fc4ebe6', 'loadClassLoader'), true, true);
        // new 自动加载核心类 ClassLoader
        self::$loader = $loader = new \Composer\Autoload\ClassLoader();
        // 销毁loadClassLoader自动加载函数
        spl_autoload_unregister(array('ComposerAutoloaderInit901467e07f0d9f8849360bc08fc4ebe6', 'loadClassLoader'));


        /**
         * ------------------------------------------------------------------------
         * 第三部分
         *
         * 初始化核心类对象
         * ------------------------------------------------------------------------
         */
        // 静态初始化方式 需要php >= 5.6 以及 不支持HHVM虚拟机
        // 为什么有php版本的要求？ 因为静态加载加速机制是opcache缓存针对静态数组优化的，只支持php5.6已上
        // HHVM是另一个虚拟机，所以没办法使用opcache https://github.com/composer/composer/pull/5174
        $useStaticLoader = PHP_VERSION_ID >= 50600 && !defined('HHVM_VERSION') && (!function_exists('zend_loader_file_encoded') || !zend_loader_file_encoded());
        if ($useStaticLoader) {
            require_once __DIR__ . '/autoload_static.php';

            // 使用call_user_func 来调用返回的匿名函数
            // 这一行不太好理解，下面给了简化的版本
            call_user_func(\Composer\Autoload\ComposerStaticInit901467e07f0d9f8849360bc08fc4ebe6::getInitializer($loader));

//            // 创建一个匿名函数，给$this变量赋值
//            $bindFunction = function () {
//                $this->prefixLengthsPsr4 = \Composer\Autoload\ComposerStaticInit901467e07f0d9f8849360bc08fc4ebe6::$prefixLengthsPsr4;
//                $this->prefixDirsPsr4 = \Composer\Autoload\ComposerStaticInit901467e07f0d9f8849360bc08fc4ebe6::$prefixDirsPsr4;
//                $this->prefixesPsr0 = \Composer\Autoload\ComposerStaticInit901467e07f0d9f8849360bc08fc4ebe6::$prefixesPsr0;
//                $this->classMap = \Composer\Autoload\ComposerStaticInit901467e07f0d9f8849360bc08fc4ebe6::$classMap;
//            };
//            // 利用bind函数讲匿名函数绑定到loader对象，并且制定类作用域为ClassLoader，为的是$bindFunction中的$this能访问私有变量
//            $bcl = \Closure::bind($bindFunction, $loader, \Composer\Autoload\ClassLoader::class);
//            // 调用该函数跟call_user_func作用一致
//            $bcl();

        } else {
            // 如果php < 5.6 或者使用HHVM 就需要使用核心类的方法进行初始化

            // PSR0 标准
            $map = require __DIR__ . '/autoload_namespaces.php';
            foreach ($map as $namespace => $path) {
                $loader->set($namespace, $path);
            }

            // PSR4 标准加载
            $map = require __DIR__ . '/autoload_psr4.php';
            foreach ($map as $namespace => $path) {
                $loader->setPsr4($namespace, $path);
            }

            // classMap 傻瓜式命名空间映射
            $classMap = require __DIR__ . '/autoload_classmap.php';
            if ($classMap) {
                $loader->addClassMap($classMap);
            }
        }

        /**
         * ------------------------------------------------------------------------
         * 第四部分
         *
         * 注册自动加载核心类对象
         * ------------------------------------------------------------------------
         */
        $loader->register(true);


        /**
         * ------------------------------------------------------------------------
         * 第五部分
         *
         * 全局函数的自动加载
         *
         * composer 也可以加载全局函数，如何实现的？
         * 把全局函数写到特定的文件中，在composer初始化的时候，挨个require就完事
         * ------------------------------------------------------------------------
         */
        if ($useStaticLoader) {
            $includeFiles = Composer\Autoload\ComposerStaticInit901467e07f0d9f8849360bc08fc4ebe6::$files;
        } else {
            $includeFiles = require __DIR__ . '/autoload_files.php';
        }
        foreach ($includeFiles as $fileIdentifier => $file) {
            composerRequire901467e07f0d9f8849360bc08fc4ebe6($fileIdentifier, $file);
        }

        return $loader;
    }
}

// 挨个require 全局函数的文件
function composerRequire901467e07f0d9f8849360bc08fc4ebe6($fileIdentifier, $file)
{
    if (empty($GLOBALS['__composer_autoload_files'][$fileIdentifier])) {
        require $file;

        $GLOBALS['__composer_autoload_files'][$fileIdentifier] = true;
    }
}
